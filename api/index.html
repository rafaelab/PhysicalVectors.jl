<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · PhysicalVectors.jl</title><meta name="title" content="API · PhysicalVectors.jl"/><meta property="og:title" content="API · PhysicalVectors.jl"/><meta property="twitter:title" content="API · PhysicalVectors.jl"/><meta name="description" content="Documentation for PhysicalVectors.jl."/><meta property="og:description" content="Documentation for PhysicalVectors.jl."/><meta property="twitter:description" content="Documentation for PhysicalVectors.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PhysicalVectors.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API</a></li><li><a class="tocitem" href="../examples/">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/rafaelab/PhysicalVectors.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="PhysicalVectors.AbstractMetric"><a class="docstring-binding" href="#PhysicalVectors.AbstractMetric"><code>PhysicalVectors.AbstractMetric</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractMetric{D, T, S} &lt;: AbstractMatrix{T}</code></pre><p>An abstract type representing a metric tensor in a <code>D</code>-dimensional space with elements of type <code>T</code>. This type is a subtype of <code>AbstractMatrix{T}</code>, indicating that it behaves like a matrix and can  be used to define geometric properties such as distances and angles in a given space.</p><p><strong>Parameters</strong></p><ul><li><code>D</code>: dimensionality of the space <br/></li><li><code>T</code>: element type of the metric tensor  <br/></li><li><code>S</code>: metric signature convention (e.g., MostlyPlus, MostlyMinus)</li></ul><p>This type is intended to be extended by concrete implementations of specific metrics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/metric.jl#L14-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.AbstractMetricSignature"><a class="docstring-binding" href="#PhysicalVectors.AbstractMetricSignature"><code>PhysicalVectors.AbstractMetricSignature</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractMetricSignature</code></pre><p>An abstract type representing the signature of a metric tensor in spacetime geometries. This type serves as a base for specific implementations of metric signatures, such as Lorentzian and Riemannian signatures.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/signatures.jl#L12-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.AbstractPhysicalVector"><a class="docstring-binding" href="#PhysicalVectors.AbstractPhysicalVector"><code>PhysicalVectors.AbstractPhysicalVector</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractPhysicalVector{D, T}</code></pre><p>An abstract type representing a physical vector with a specific dimension <code>D</code> and element type <code>T</code>. <br/>This type inherits from <code>AbstractVector{T}</code> and serves as a base type for defining vectors that have physical or geometric interpretations.</p><p><strong>Parameters</strong></p><ul><li><code>D</code>: dimension of the vector (e.g., 2 for 2D, 3 for 3D) <br/></li><li><code>T</code>: type of the elements in the vector (e.g., <code>Float64</code>) <br/></li></ul><p>This type is intended to be extended by concrete implementations that define specific behaviours and properties of physical vectors. For instance, <code>VectorLorentz</code> and <code>VectorEuclidean</code> are such concrete sub-types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/vector.jl#L3-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.FourCurrentDensity"><a class="docstring-binding" href="#PhysicalVectors.FourCurrentDensity"><code>PhysicalVectors.FourCurrentDensity</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct FourCurrentDensity{D, T, V &lt;: StaticVector{D, T}} &lt;: AbstractPhysicalVector{D, T}</code></pre><p>Constructors for the <code>FourCurrentDensity</code> type. This is a usual <code>FourXXX</code> quantity.  This structure allows for new methods and explicit dispatching.</p><p><strong>Parameters</strong></p><ul><li><code>D</code>: the dimensionality of the vector</li><li><code>T</code>: the numeric type of the vector elements (e.g., <code>AbstractFloat</code>)</li><li><code>V</code>: a subtype of <code>StaticVector</code> representing the underlying vector type</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/vector/lorentz.jl#L166-L177">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.FourMomentum"><a class="docstring-binding" href="#PhysicalVectors.FourMomentum"><code>PhysicalVectors.FourMomentum</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct FourMomentum{D, T, V &lt;: StaticVector{D, T}} &lt;: AbstractPhysicalVector{D, T}</code></pre><p>Constructors for the <code>FourMomentum</code> type. This is a usual <code>FourXXX</code> quantity.  This structure allows for new methods and explicit dispatching.</p><p><strong>Parameters</strong></p><ul><li><code>D</code>: the dimensionality of the vector</li><li><code>T</code>: the numeric type of the vector elements (e.g., <code>AbstractFloat</code>)</li><li><code>V</code>: a subtype of <code>StaticVector</code> representing the underlying vector type</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/vector/lorentz.jl#L166-L177">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.FourPosition"><a class="docstring-binding" href="#PhysicalVectors.FourPosition"><code>PhysicalVectors.FourPosition</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct FourPosition{D, T, V &lt;: StaticVector{D, T}} &lt;: AbstractPhysicalVector{D, T}</code></pre><p>Constructors for the <code>FourPosition</code> type. This is a usual <code>FourXXX</code> quantity.  This structure allows for new methods and explicit dispatching.</p><p><strong>Parameters</strong></p><ul><li><code>D</code>: the dimensionality of the vector</li><li><code>T</code>: the numeric type of the vector elements (e.g., <code>AbstractFloat</code>)</li><li><code>V</code>: a subtype of <code>StaticVector</code> representing the underlying vector type</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/vector/lorentz.jl#L166-L177">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.FourVelocity"><a class="docstring-binding" href="#PhysicalVectors.FourVelocity"><code>PhysicalVectors.FourVelocity</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct FourVelocity{D, T, V &lt;: StaticVector{D, T}} &lt;: AbstractPhysicalVector{D, T}</code></pre><p>Constructors for the <code>FourVelocity</code> type. This is a usual <code>FourXXX</code> quantity.  This structure allows for new methods and explicit dispatching.</p><p><strong>Parameters</strong></p><ul><li><code>D</code>: the dimensionality of the vector</li><li><code>T</code>: the numeric type of the vector elements (e.g., <code>AbstractFloat</code>)</li><li><code>V</code>: a subtype of <code>StaticVector</code> representing the underlying vector type</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/vector/lorentz.jl#L166-L177">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.LorentzianMetricSignatureConvention"><a class="docstring-binding" href="#PhysicalVectors.LorentzianMetricSignatureConvention"><code>PhysicalVectors.LorentzianMetricSignatureConvention</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LorentzMetricSignatureConvention</code></pre><p>Abstract type representing a convention for metric signature in spacetime geometries. This is implemented for completeness. The mostly-plus signature is obviously the better one, despite the wide adoption of the mostly-minus convetion in high-energy physics.</p><p><strong>Sub-types</strong></p><ul><li><code>MostlyMinus</code>: Represents the &quot;mostly minus&quot; convention, where the metric signature is typically (+, -, -, -, ...)</li><li><code>MostlyPlus</code>: Represents the &quot;mostly plus&quot; convention, where the metric signature is typically (-, +, +, +, ...)</li></ul><p>These types can be used to specify the metric signature convention in calculations involving spacetime metrics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/signatures.jl#L34-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.MetricEuclid"><a class="docstring-binding" href="#PhysicalVectors.MetricEuclid"><code>PhysicalVectors.MetricEuclid</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MetricEuclid</code></pre><p>A structure representing an Euclidean metric in <code>D</code>-dimensional space.  This metric is parameterised by:</p><ul><li><code>D</code>: the dimensionality of the space</li><li><code>T</code>: the numeric type of the elements (e.g., <code>Float64</code>)</li></ul><p>This type is a subtype of <code>AbstractMetric{N, T}</code> and is used to represent and work with Euclidean metrics in a statically-typed manner.</p><p><strong>Fields</strong></p><ul><li><code>metric::V</code>: a static matrix that defines the Euclidean metric</li></ul><p><strong>Available constructors</strong></p><ul><li><code>MetricEuclid(m::AbstractMatrix{D, D, T})</code></li><li><code>MetricEuclid(d::Integer, ::Type{T})</code></li><li><code>MetricEuclid(d::Integer)</code></li><li><code>MetricEuclid()</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/metric/euclid.jl#L9-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.MetricMinkowski"><a class="docstring-binding" href="#PhysicalVectors.MetricMinkowski"><code>PhysicalVectors.MetricMinkowski</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MetricMinkowski</code></pre><p>A structure representing the Minkowski metric in an N-dimensional space. This metric is parameterised by:</p><ul><li><code>D</code>: the dimensionality of the space </li><li><code>T</code>: the numeric type of the elements (e.g., <code>Float64</code>, <code>Int64</code>)</li></ul><p>This type is a subtype of <code>AbstractMetric{D, T}</code> and is used to represent and work with Euclidean metrics in a statically-typed manner. The last element of the metric is the time-dependent one.</p><p><strong>Fields</strong></p><ul><li><code>metric::V</code>: a static matrix that defines the Minkowski metric</li></ul><p><strong>Available constructors</strong></p><ul><li><code>MetricMinkowski(d::Integer, ::Type{T}, ::Type{S})</code></li><li><code>MetricMinkowski(d::Integer, ::Type{S}, ::Type{T})</code></li><li><code>MetricMinkowski(d::Integer, ::Type{T})</code></li><li><code>MetricMinkowski(d::Integer, ::Type{S})</code></li><li><code>MetricMinkowski(d::Integer)</code></li><li><code>MetricMinkowski()</code> (1-dimensional default)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/metric/minkowski.jl#L9-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.MetricSignatureLorentzian"><a class="docstring-binding" href="#PhysicalVectors.MetricSignatureLorentzian"><code>PhysicalVectors.MetricSignatureLorentzian</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MetricSignatureLorentzian{S} &lt;: AbstractMetricSignature</code></pre><p>A struct representing a Lorentzian metric signature, where one dimension is treated differently (typically time) compared to the others (typically space).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/signatures.jl#L76-L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.MetricSignatureRiemannian"><a class="docstring-binding" href="#PhysicalVectors.MetricSignatureRiemannian"><code>PhysicalVectors.MetricSignatureRiemannian</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MetricSignatureRiemannian &lt;: AbstractMetricSignature</code></pre><p>A struct representing a Riemannian metric signature, where all dimensions are treated equally and positively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/signatures.jl#L23-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.MostlyMinus"><a class="docstring-binding" href="#PhysicalVectors.MostlyMinus"><code>PhysicalVectors.MostlyMinus</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MostlyMinus</code></pre><p>In this case, the corresponding Minkowski-like metric has the signature (+, -, -, -). This is the convention used in high-energy physics, where the time component is positive and the spatial components are negative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/signatures.jl#L52-L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.MostlyPlus"><a class="docstring-binding" href="#PhysicalVectors.MostlyPlus"><code>PhysicalVectors.MostlyPlus</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MostlyPlus</code></pre><p>In this case, the corresponding Minkowski-like metric has the signature (-, +, +, +). This is the convention used in general relativity, where the time component is negative and the spatial components are positive.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/signatures.jl#L64-L69">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.VectorLorentz"><a class="docstring-binding" href="#PhysicalVectors.VectorLorentz"><code>PhysicalVectors.VectorLorentz</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VectorLorentz{D, T, V &lt;: StaticVector{D, T}}</code></pre><p>A structure representing a Lorentzian vector in a physical vector space.\  It is parameterised by:<br/>- <code>D</code>: dimensionality of the vector <br/>- <code>T</code>: element type of the vector <br/>- <code>V</code>: sub-type of <code>StaticVector{D, T}</code> representing the underlying static vector <br/></p><p><strong>Fields</strong></p><ul><li><code>vector::V</code>: the underlying static vector storing the data</li></ul><p><strong>Available constructors</strong></p><ul><li><code>VectorLorentz(v::StaticVector{D, T})</code></li><li><code>VectorLorentz(v::AbstractVector{T})</code></li><li><code>VectorLorentz(vs::Vararg{&lt;: Number})</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/vector/lorentz.jl#L18-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.VectorSpatial"><a class="docstring-binding" href="#PhysicalVectors.VectorSpatial"><code>PhysicalVectors.VectorSpatial</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VectorSpatial{D, T, V &lt;: StaticVector{D, T}}</code></pre><p>A structure representing a spatial vector in a physical vector space.\  It is parameterised by:<br/>- <code>D</code>: dimensionality of the vector <br/>- <code>T</code>: element type of the vector <br/>- <code>V</code>: sub-type of <code>StaticVector{D, T}</code> representing the underlying static vector <br/></p><p><strong>Fields</strong></p><ul><li><code>vector::V</code>: the underlying static vector storing the data.</li></ul><p><strong>Available constructors</strong></p><ul><li><code>VectorSpatial(v::StaticVector{D, T})</code></li><li><code>VectorSpatial(v::AbstractVector{T})</code></li><li><code>VectorSpatial(vs::Vararg{&lt;: Number})</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/vector/spatial.jl#L10-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LinearAlgebra.cross"><a class="docstring-binding" href="#LinearAlgebra.cross"><code>LinearAlgebra.cross</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cross</code></pre><p>Defines the <code>cross</code> function commonly used for vector products.  This is a placeholder definition and should be extended with specific methods for the desired types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/algebra.jl#L22-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LinearAlgebra.cross-Tuple{VectorSpatial, VectorSpatial}"><a class="docstring-binding" href="#LinearAlgebra.cross-Tuple{VectorSpatial, VectorSpatial}"><code>LinearAlgebra.cross</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cross(v1::VectorSpatial, v2::VectorSpatial) -&gt; VectorSpatial</code></pre><p>Compute the cross product of two 3D spatial vectors <code>v1</code> and <code>v2</code>.<br/>This function is only defined for 3-dimensional vectors.<br/>It throw a <code>DimensionMismatch</code> error if the vectors are not 3D.<br/></p><p><strong>Input</strong></p><ul><li><code>v1::VectorSpatial</code>:  first 3D spatial vector</li><li><code>v2::VectorSpatial</code>:  second 3D spatial vector</li></ul><p><strong>Output</strong></p><ul><li>A new <code>VectorSpatial</code> object representing the cross product of <code>v1</code> and <code>v2</code>.</li></ul><p><strong>Notes</strong></p><p>The cross product is only defined for 3-dimensional vectors. Ensure that both input vectors have a length of 3 before calling this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/vector/spatial.jl#L79-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LinearAlgebra.dot"><a class="docstring-binding" href="#LinearAlgebra.dot"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">dot</code></pre><p>Defines the <code>dot</code> function, which is typically used to compute the dot product of two vectors.  This is a placeholder definition and should be extended with specific methods for the desired types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/algebra.jl#L11-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LinearAlgebra.dot-Tuple{VectorSpatial, VectorSpatial}"><a class="docstring-binding" href="#LinearAlgebra.dot-Tuple{VectorSpatial, VectorSpatial}"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dot(v1::VectorSpatial{D, T1}, v2::VectorSpatial{D, T2}) -&gt; Number
dot(v1::VectorSpatial{D, T1}, v2::VectorSpatial{D, T2}, m::AbstractMetric) -&gt; Number</code></pre><p>Computes the dot product of two spatial vectors <code>v1</code> and <code>v2</code> using their internal vector representations, for a given metric <code>m</code>. <br/>The metric here makes no difference whatsoever, as the dot product is invariant under any metric, by construction.<br/>The method involving the metric is included for consistency with the Lorentzian case.<br/></p><p><strong>Input</strong></p><ul><li><code>v1::VectorLorentz</code>: first Lorentz vector</li><li><code>v2::VectorLorentz</code>: second Lorentz vector</li></ul><p>. (optional) <code>m::AbstractMetric</code>: an <code>AbstractMetric</code>-type object; defaults to Minkowski</p><p><strong>Output</strong></p><ul><li><code>Number</code>: the dot product of the two Lorentz vectors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/vector/spatial.jl#L51-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LinearAlgebra.dot-Union{Tuple{U}, Tuple{D}, Tuple{VectorLorentz, VectorLorentz, MetricMinkowski{D, U, MostlyMinus}}} where {D, U}"><a class="docstring-binding" href="#LinearAlgebra.dot-Union{Tuple{U}, Tuple{D}, Tuple{VectorLorentz, VectorLorentz, MetricMinkowski{D, U, MostlyMinus}}} where {D, U}"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dot(v1::VectorLorentz, v2::VectorLorentz, m::AbstractMetric) -&gt; Number
dot(v1::VectorLorentz{D, T1, V}, v2::VectorLorentz{D, T2, V}, ::MetricEuclid{D, U}) -&gt; T
dot(v1::VectorLorentz{D, T1, V}, v2::VectorLorentz{D, T2, V}, ::MetricMinkowski{D, U, S}) -&gt; T</code></pre><p>Computes the dot product of two Lorentz vectors <code>v1</code> and <code>v2</code> using their internal vector representations, for a given metric <code>m</code>. <br/></p><p><strong>Input</strong></p><ul><li><code>v1::VectorLorentz</code>: first Lorentz vector</li><li><code>v2::VectorLorentz</code>: second Lorentz vector</li></ul><p><strong>Output</strong></p><p>&quot;- <code>Number</code>: the dot product of the two Lorentz vectors.&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/vector/lorentz.jl#L107-L120">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LinearAlgebra.norm-Tuple{PhysicalVectors.AbstractPhysicalVector}"><a class="docstring-binding" href="#LinearAlgebra.norm-Tuple{PhysicalVectors.AbstractPhysicalVector}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">norm(v::AbstractPhysicalVector{D, T}) -&gt; T
norm(v::AbstractPhysicalVector{D, T}, m::AbstractMetric{D, U, S}) -&gt; T</code></pre><p>Compute the norm of a Lorentz vector <code>v</code> using the default metric.  The norm is defined as the square root of the dot product of the vector with itself.</p><p><strong>Input</strong></p><ul><li><code>v::VectorLorentz</code>: the Lorentz vector whose norm is to be computed.</li></ul><p><strong>Output</strong></p><ul><li><code>T</code>: The computed norm of the Lorentz vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/algebra.jl#L59-L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.getChargeDensity-Union{Tuple{FourCurrentDensity{D, T, V}}, Tuple{V}, Tuple{T}, Tuple{D}} where {D, T&lt;:Real, V}"><a class="docstring-binding" href="#PhysicalVectors.getChargeDensity-Union{Tuple{FourCurrentDensity{D, T, V}}, Tuple{V}, Tuple{T}, Tuple{D}} where {D, T&lt;:Real, V}"><code>PhysicalVectors.getChargeDensity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getChargeDensity(v::FourCurrentDensity) -&gt; AbstractFloat</code></pre><p>Computes the charge density of a <code>FourCurrentDensity</code> object <code>v</code>. The charge density is calculated as the temporal part of the four-current divided by the speed of light <code>c</code>.</p><p><strong>Input</strong></p><ul><li><code>v::FourCurrentDensity</code>: four-current object for which the charge density is to be computed </li></ul><p><strong>Output</strong></p><ul><li><code>AbstractFloat</code>: the charge density corresponding to the given four-current in units of C/m³</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/vector/lorentz.jl#L301-L312">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.getCurrentDensity-Tuple{FourCurrentDensity}"><a class="docstring-binding" href="#PhysicalVectors.getCurrentDensity-Tuple{FourCurrentDensity}"><code>PhysicalVectors.getCurrentDensity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getCurrent(v::FourCurrentDensity) -&gt; VectorSpatial</code></pre><p>Extracts the spatial part of a <code>FourCurrentDensity</code> object.</p><p><strong>Input</strong></p><ul><li><code>v::FourCurrentDensity</code>: the four-current object from which the spatial part (current) is to be extracted</li></ul><p><strong>Output</strong></p><ul><li>The <code>VectorSpatial</code> representing the spatial current component of the input <code>FourCurrentDensity</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/vector/lorentz.jl#L323-L333">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.getEnergy-Union{Tuple{FourMomentum{D, T, V}}, Tuple{V}, Tuple{T}, Tuple{D}} where {D, T&lt;:Real, V}"><a class="docstring-binding" href="#PhysicalVectors.getEnergy-Union{Tuple{FourMomentum{D, T, V}}, Tuple{V}, Tuple{T}, Tuple{D}} where {D, T&lt;:Real, V}"><code>PhysicalVectors.getEnergy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getEnergy(v::FourMomentum) -&gt; AbstractFloat</code></pre><p>Compute the energy of a <code>FourMomentum</code> object <code>v</code>.  The energy is calculated as the temporal part of the four-momentum multiplied by the speed of light <code>c</code>.</p><p><strong>Input</strong></p><ul><li><code>v::FourMomentum</code>: four-momentum object for which the energy is to be computed</li></ul><p><strong>Output</strong></p><ul><li><code>AbstractFloat</code>: the energy corresponding to the given four-momentum in units of Joules</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/vector/lorentz.jl#L262-L273">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.getLorentzianSignatureConvention-Union{Tuple{Type{MetricSignatureLorentzian{S}}}, Tuple{S}} where S"><a class="docstring-binding" href="#PhysicalVectors.getLorentzianSignatureConvention-Union{Tuple{Type{MetricSignatureLorentzian{S}}}, Tuple{S}} where S"><code>PhysicalVectors.getLorentzianSignatureConvention</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getLorentzianSignatureConvention(::Type{MetricSignatureLorentzian{S}}) where {S &lt;: LorentzianMetricSignatureConvention} -&gt; S</code></pre><p>Retrieve the signature convention type from a <code>MetricSignatureLorentzian</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/signatures.jl#L87-L91">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.getMetricSignatureSign-Union{Tuple{Type{PhysicalVectors.AbstractMetric{D, T, MetricSignatureRiemannian}}}, Tuple{T}, Tuple{D}} where {D, T}"><a class="docstring-binding" href="#PhysicalVectors.getMetricSignatureSign-Union{Tuple{Type{PhysicalVectors.AbstractMetric{D, T, MetricSignatureRiemannian}}}, Tuple{T}, Tuple{D}} where {D, T}"><code>PhysicalVectors.getMetricSignatureSign</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getMetricSignatureSign(::AbstractMetric)
getMetricSignatureSign(::Type{AbstractMetric})</code></pre><p>Retrieves the signature sign of the metric.</p><p><strong>Output</strong></p><ul><li><code>+1</code> for &quot;mostly plus&quot; convention</li><li><code>-1</code> for &quot;mostly minus&quot; convention</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/metric.jl#L91-L100">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.getMetricTensor-Union{Tuple{PhysicalVectors.AbstractMetric{D, T, S}}, Tuple{S}, Tuple{T}, Tuple{D}} where {D, T, S}"><a class="docstring-binding" href="#PhysicalVectors.getMetricTensor-Union{Tuple{PhysicalVectors.AbstractMetric{D, T, S}}, Tuple{S}, Tuple{T}, Tuple{D}} where {D, T, S}"><code>PhysicalVectors.getMetricTensor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getMetric(m::AbstractMetric{D, T, S}) -&gt; T</code></pre><p>Retrieve the metric tensor from an <code>AbstractMetric</code> object.</p><p><strong>Input</strong></p><ul><li><code>m::AbstractMetric{D, T, S}</code>: an instance of a subtype of <code>AbstractMetric</code>, where <code>D</code> is the dimensionality, <code>T</code> is the type of the metric tensor, and <code>S</code> is the metric signature convention.</li></ul><p><strong>Output</strong></p><ul><li><code>T</code>: the metric tensor associated with the given <code>AbstractMetric</code> object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/metric.jl#L50-L60">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.getMomentum-Tuple{FourMomentum}"><a class="docstring-binding" href="#PhysicalVectors.getMomentum-Tuple{FourMomentum}"><code>PhysicalVectors.getMomentum</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getMomentum(v::FourMomentum) -&gt; VectorSpatial</code></pre><p>Extracts the spatial part of a <code>FourMomentum</code> object.</p><p><strong>Input</strong></p><ul><li><code>v::FourMomentum</code>: the four-momentum object from which the spatial part (momentum) is to be extracted</li></ul><p><strong>Output</strong></p><ul><li>The <code>VectorSpatial</code> representing the spatial momentum component of the input <code>FourMomentum</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/vector/lorentz.jl#L285-L295">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.getPosition-Tuple{FourPosition}"><a class="docstring-binding" href="#PhysicalVectors.getPosition-Tuple{FourPosition}"><code>PhysicalVectors.getPosition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getPosition(p::FourPosition) -&gt; VectorSpatial</code></pre><p>Retrieve the spatial part of a <code>FourPosition</code> object.</p><p><strong>Input</strong></p><ul><li><code>v::FourPosition</code>: four-position object from which the time component is extracted</li></ul><p><strong>Output</strong></p><ul><li><code>VectorSpatial</code>: the spatial part of the four-position</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/vector/lorentz.jl#L246-L256">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.getSpatialPart-Tuple{VectorLorentz}"><a class="docstring-binding" href="#PhysicalVectors.getSpatialPart-Tuple{VectorLorentz}"><code>PhysicalVectors.getSpatialPart</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getSpatialPart(v::VectorLorentz) -&gt; VectorSpatial</code></pre><p>Extracts the spatial part of a <code>VectorLorentz</code> object. <br/>The spatial part is obtained by taking all elements of the internal vector except the last one. <br/></p><p><strong>Input</strong></p><ul><li><code>v::VectorLorentz</code>: a Lorentz vector from which the spatial part is to be extracted. </li><li><code>m::AbstractMetric</code>: an <code>AbstractMetric</code>-type object; defaults to Minkowski</li></ul><p><strong>Output</strong></p><ul><li><code>VectorSpatial</code>: an Euclidean vector containing the spatial components of the input Lorentz vector.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/vector/lorentz.jl#L64-L76">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.getTemporalPart-Tuple{VectorLorentz}"><a class="docstring-binding" href="#PhysicalVectors.getTemporalPart-Tuple{VectorLorentz}"><code>PhysicalVectors.getTemporalPart</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getTemporalPart(v::VectorLorentz) -&gt; Vector{T}</code></pre><p>Extracts the temporal part of a <code>VectorLorentz</code> object. <br/>The temporal part is assumed to be the last element of the vector representation.</p><p><strong>Input</strong></p><ul><li><code>v::VectorLorentz</code>: Lorentz vector from which the temporal part is to be extracted</li></ul><p><strong>Output</strong></p><ul><li>A one-element vector containing the temporal part of the input <code>VectorLorentz</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/vector/lorentz.jl#L85-L96">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.getTime-Union{Tuple{FourPosition{D, T, V}}, Tuple{V}, Tuple{T}, Tuple{D}} where {D, T&lt;:Real, V}"><a class="docstring-binding" href="#PhysicalVectors.getTime-Union{Tuple{FourPosition{D, T, V}}, Tuple{V}, Tuple{T}, Tuple{D}} where {D, T&lt;:Real, V}"><code>PhysicalVectors.getTime</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getTime(p::FourPosition) -&gt; AbstractFloat</code></pre><p>Computes the time component of a <code>FourPosition</code> object by dividing its temporal part by the speed of light <code>c</code>.</p><p><strong>Input</strong></p><ul><li><code>v::FourPosition</code>: four-position object from which the time component is extracted</li></ul><p><strong>Output</strong></p><ul><li><code>AbstractFloat</code>: the time component of the four-position</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/vector/lorentz.jl#L225-L235">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.isMetricLorentzian-Union{Tuple{PhysicalVectors.AbstractMetric{D, T, MetricSignatureRiemannian}}, Tuple{T}, Tuple{D}} where {D, T}"><a class="docstring-binding" href="#PhysicalVectors.isMetricLorentzian-Union{Tuple{PhysicalVectors.AbstractMetric{D, T, MetricSignatureRiemannian}}, Tuple{T}, Tuple{D}} where {D, T}"><code>PhysicalVectors.isMetricLorentzian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isMetricRiemannian(m::AbstractMetric{D, T, S}) -&gt; Bool
isMetricLorentzian(m::AbstractMetric{D, T, S}) -&gt; Bool</code></pre><p>Determines whether the given metric is Riemannian or Lorentzian based on its signature.</p><p><strong>Input</strong></p><ul><li><code>m::AbstractMetric{D, T, S}</code>: an instance of a subtype of <code>AbstractMetric</code>, where <code>D</code> is the dimensionality, <code>T</code> is the type of the metric tensor, and <code>S</code> is the metric signature convention.</li></ul><p><strong>Output</strong></p><ul><li><code>true</code> if the metric is Lorentzian</li><li><code>false</code> if the metric is Riemannian</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/metric.jl#L127-L139">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.isMetricRiemannian-Union{Tuple{PhysicalVectors.AbstractMetric{D, T, MetricSignatureRiemannian}}, Tuple{T}, Tuple{D}} where {D, T}"><a class="docstring-binding" href="#PhysicalVectors.isMetricRiemannian-Union{Tuple{PhysicalVectors.AbstractMetric{D, T, MetricSignatureRiemannian}}, Tuple{T}, Tuple{D}} where {D, T}"><code>PhysicalVectors.isMetricRiemannian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isMetricRiemannian(m::AbstractMetric{D, T, S}) -&gt; Bool
isMetricLorentzian(m::AbstractMetric{D, T, S}) -&gt; Bool</code></pre><p>Determines whether the given metric is Riemannian or Lorentzian based on its signature.</p><p><strong>Input</strong></p><ul><li><code>m::AbstractMetric{D, T, S}</code>: an instance of a subtype of <code>AbstractMetric</code>, where <code>D</code> is the dimensionality, <code>T</code> is the type of the metric tensor, and <code>S</code> is the metric signature convention.</li></ul><p><strong>Output</strong></p><ul><li><code>true</code> if the metric is Riemannian</li><li><code>false</code> if the metric is Lorentzian</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/metric.jl#L108-L120">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.isMostlyPlus-Union{Tuple{PhysicalVectors.AbstractMetric{D, T, MetricSignatureRiemannian}}, Tuple{T}, Tuple{D}} where {D, T}"><a class="docstring-binding" href="#PhysicalVectors.isMostlyPlus-Union{Tuple{PhysicalVectors.AbstractMetric{D, T, MetricSignatureRiemannian}}, Tuple{T}, Tuple{D}} where {D, T}"><code>PhysicalVectors.isMostlyPlus</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isMostlyPlus(m::MetricMinkowski) -&gt; Bool
isMostlyMinus(m::MetricMinkowski) -&gt; Bool</code></pre><p>Determines the signature convention of the Minkowski metric. </p><p><strong>Input</strong></p><ul><li><code>m::MetricMinkowski{D, T, MostlyPlus}</code>:  Minkowski metric object with &quot;mostly plus&quot; convention</li><li><code>m::MetricMinkowski{D, T, MostlyMinus}</code>:  Minkowski metric object with &quot;mostly minus&quot; convention</li></ul><p><strong>Output</strong></p><ul><li><code>true</code> if the metric is &quot;mostly plus&quot;</li><li><code>false</code> if the metric is &quot;mostly minus&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/metric.jl#L66-L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.norm2-Tuple{PhysicalVectors.AbstractPhysicalVector}"><a class="docstring-binding" href="#PhysicalVectors.norm2-Tuple{PhysicalVectors.AbstractPhysicalVector}"><code>PhysicalVectors.norm2</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">norm2(v::AbstractPhysicalVector{D, T}) -&gt; T
norm2(v::AbstractPhysicalVector{D, T}, m::AbstractMetric{D, U, S}) -&gt; T
norm²(args...) -&gt; T</code></pre><p>Compute the squared norm of a Lorentz vector <code>v</code> using the default metric.  The norm is defined as the square root of the dot product of the vector with itself.</p><p><strong>Input</strong></p><ul><li><code>v::AbstractPhysicalVector</code>: the vector</li><li><code>m::AbstractMetric</code>: the metric used to compute the dot product (optional)</li></ul><p><strong>Output</strong></p><ul><li><code>T</code>: The computed norm2 of the Lorentz vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/algebra.jl#L33-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.numberOfDimensions"><a class="docstring-binding" href="#PhysicalVectors.numberOfDimensions"><code>PhysicalVectors.numberOfDimensions</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">numberOfDimensions(metric::AbstractMetric{D, T}) -&gt; D
numberOfDimensions(vector::AbstractPhysicalVector{D, T}) -&gt; D</code></pre><p>Retrieve the number of dimensions of an object. This function is <em>not</em> exported, as it is intended for internal use within packages.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/common.jl#L9-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.numberOfDimensions-Union{Tuple{PhysicalVectors.AbstractPhysicalVector{D, T}}, Tuple{T}, Tuple{D}} where {D, T}"><a class="docstring-binding" href="#PhysicalVectors.numberOfDimensions-Union{Tuple{PhysicalVectors.AbstractPhysicalVector{D, T}}, Tuple{T}, Tuple{D}} where {D, T}"><code>PhysicalVectors.numberOfDimensions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">numberOfDimensions(v::AbstractPhysicalVector{D, T}) -&gt; D</code></pre><p>Returns the number of dimensions of a given physical vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/vector.jl#L98-L102">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.@generateFourVector-Tuple{Any}"><a class="docstring-binding" href="#PhysicalVectors.@generateFourVector-Tuple{Any}"><code>PhysicalVectors.@generateFourVector</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@generateFourVector(quantity)</code></pre><p>Macro to generate a <code>FourQuantity</code> type and its associated methods.</p><p>This macro defines a new struct type for a four-dimensional physical quantity,  along with constructors and utility methods for operations such as dot products  and accessing temporal and spatial parts.</p><p><strong>Input</strong></p><ul><li><code>quantity</code>: name of the four-dimensional quantity to be generated</li></ul><p><strong>Generated Code</strong></p><ul><li>A struct definition for the <code>quantity</code> type, which is a subtype of <code>AbstractPhysicalVector</code></li><li>Constructors for the <code>quantity</code> type:</li></ul><pre><code class="language-julia hljs">-- from a `VectorLorentz` object
-- from an `AbstractVector`
-- from a variable number of scalar arguments</code></pre><ul><li>Overloaded <code>Base.getproperty</code> to delegate property access to the underlying <code>VectorLorentz</code></li><li>Utility functions:</li></ul><pre><code class="language-julia hljs">-- `getTemporalPart`: the temporal part of the vector
-- `getSpatialPart`:retrieves the spatial part of the vector
-- `dot`: computes the dot product of two `quantity` objects, optionally using a metric</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/vector/lorentz.jl#L140-L163">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhysicalVectors.@physicalVectorConstructors-Tuple{Any}"><a class="docstring-binding" href="#PhysicalVectors.@physicalVectorConstructors-Tuple{Any}"><code>PhysicalVectors.@physicalVectorConstructors</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@physicalVectorConstructors(vector)</code></pre><p>A macro that generates constructor methods for a custom <code>VectorXXX</code> sub-typing from <code>AbstractPhysicalVector</code>.<br/>This macro is not exported and is intended for internal use within the package. <br/>The generated constructors allow for the creation of <code>VectorXXX</code> instances from different input types, including: <br/>1. Static Vectors (<code>SVector</code>):<br/>. Accepts an <code>SVector{D, T}</code> where <code>D</code> is the dimension and <code>T</code> is a subtype of <code>Number</code>. <br/>. Returns an instance of <code>vector</code> parameterised by <code>D</code>, <code>T</code>, and the type of the input vector. <br/>2. Abstract Vectors: <br/>. Accepts an <code>AbstractVector{T}</code> where <code>T</code> is a subtype of <code>Number</code>. <br/>. Converts the input vector to a mutable <code>MVector</code> and returns an instance of <code>vector</code> parameterised by the length of the input vector, <code>T</code>, and the type of the converted vector. <br/>3. Varargs: <br/>. Accepts a variable number of arguments of type <code>T</code> (where <code>T</code> is a subtype of <code>Number</code>). <br/>. Constructs an <code>MVector</code> from the arguments and returns an instance of <code>vector</code>. <br/>This macro simplifies the creation of constructors for custom vector types, ensuring compatibility with various input formats.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaelab/PhysicalVectors.jl/blob/0d188103c08412db8feddf7cdc22ae5135b04689/src/vector.jl#L39-L55">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 24 November 2025 17:13">Monday 24 November 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
