var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#PhysicalVectors.AbstractMetric","page":"API","title":"PhysicalVectors.AbstractMetric","text":"AbstractMetric{D, T, S} <: AbstractMatrix{T}\n\nAn abstract type representing a metric tensor in a D-dimensional space with elements of type T. This type is a subtype of AbstractMatrix{T}, indicating that it behaves like a matrix and can  be used to define geometric properties such as distances and angles in a given space.\n\nParameters\n\nD: dimensionality of the space \n\nT: element type of the metric tensor  \n\nS: metric signature convention (e.g., MostlyPlus, MostlyMinus)\n\nThis type is intended to be extended by concrete implementations of specific metrics.\n\n\n\n\n\n","category":"type"},{"location":"api/#PhysicalVectors.AbstractMetricSignature","page":"API","title":"PhysicalVectors.AbstractMetricSignature","text":"AbstractMetricSignature\n\nAn abstract type representing the signature of a metric tensor in spacetime geometries. This type serves as a base for specific implementations of metric signatures, such as Lorentzian and Riemannian signatures.\n\n\n\n\n\n","category":"type"},{"location":"api/#PhysicalVectors.AbstractPhysicalVector","page":"API","title":"PhysicalVectors.AbstractPhysicalVector","text":"AbstractPhysicalVector{D, T}\n\nAn abstract type representing a physical vector with a specific dimension D and element type T. \nThis type inherits from AbstractVector{T} and serves as a base type for defining vectors that have physical or geometric interpretations.\n\nParameters\n\nD: dimension of the vector (e.g., 2 for 2D, 3 for 3D) \n\nT: type of the elements in the vector (e.g., Float64) \n\n\nThis type is intended to be extended by concrete implementations that define specific behaviours and properties of physical vectors. For instance, VectorLorentz and VectorEuclidean are such concrete sub-types.\n\n\n\n\n\n","category":"type"},{"location":"api/#PhysicalVectors.FourCurrentDensity","page":"API","title":"PhysicalVectors.FourCurrentDensity","text":"struct FourCurrentDensity{D, T, V <: StaticVector{D, T}} <: AbstractPhysicalVector{D, T}\n\nConstructors for the FourCurrentDensity type. This is a usual FourXXX quantity.  This structure allows for new methods and explicit dispatching.\n\nParameters\n\nD: the dimensionality of the vector\nT: the numeric type of the vector elements (e.g., AbstractFloat)\nV: a subtype of StaticVector representing the underlying vector type\n\n\n\n\n\n","category":"type"},{"location":"api/#PhysicalVectors.FourMomentum","page":"API","title":"PhysicalVectors.FourMomentum","text":"struct FourMomentum{D, T, V <: StaticVector{D, T}} <: AbstractPhysicalVector{D, T}\n\nConstructors for the FourMomentum type. This is a usual FourXXX quantity.  This structure allows for new methods and explicit dispatching.\n\nParameters\n\nD: the dimensionality of the vector\nT: the numeric type of the vector elements (e.g., AbstractFloat)\nV: a subtype of StaticVector representing the underlying vector type\n\n\n\n\n\n","category":"type"},{"location":"api/#PhysicalVectors.FourPosition","page":"API","title":"PhysicalVectors.FourPosition","text":"struct FourPosition{D, T, V <: StaticVector{D, T}} <: AbstractPhysicalVector{D, T}\n\nConstructors for the FourPosition type. This is a usual FourXXX quantity.  This structure allows for new methods and explicit dispatching.\n\nParameters\n\nD: the dimensionality of the vector\nT: the numeric type of the vector elements (e.g., AbstractFloat)\nV: a subtype of StaticVector representing the underlying vector type\n\n\n\n\n\n","category":"type"},{"location":"api/#PhysicalVectors.FourVelocity","page":"API","title":"PhysicalVectors.FourVelocity","text":"struct FourVelocity{D, T, V <: StaticVector{D, T}} <: AbstractPhysicalVector{D, T}\n\nConstructors for the FourVelocity type. This is a usual FourXXX quantity.  This structure allows for new methods and explicit dispatching.\n\nParameters\n\nD: the dimensionality of the vector\nT: the numeric type of the vector elements (e.g., AbstractFloat)\nV: a subtype of StaticVector representing the underlying vector type\n\n\n\n\n\n","category":"type"},{"location":"api/#PhysicalVectors.LorentzianMetricSignatureConvention","page":"API","title":"PhysicalVectors.LorentzianMetricSignatureConvention","text":"LorentzMetricSignatureConvention\n\nAbstract type representing a convention for metric signature in spacetime geometries. This is implemented for completeness. The mostly-plus signature is obviously the better one, despite the wide adoption of the mostly-minus convetion in high-energy physics.\n\nSub-types\n\nMostlyMinus: Represents the \"mostly minus\" convention, where the metric signature is typically (+, -, -, -, ...)\nMostlyPlus: Represents the \"mostly plus\" convention, where the metric signature is typically (-, +, +, +, ...)\n\nThese types can be used to specify the metric signature convention in calculations involving spacetime metrics.\n\n\n\n\n\n","category":"type"},{"location":"api/#PhysicalVectors.MetricEuclid","page":"API","title":"PhysicalVectors.MetricEuclid","text":"MetricEuclid\n\nA structure representing an Euclidean metric in D-dimensional space.  This metric is parameterised by:\n\nD: the dimensionality of the space\nT: the numeric type of the elements (e.g., Float64)\n\nThis type is a subtype of AbstractMetric{N, T} and is used to represent and work with Euclidean metrics in a statically-typed manner.\n\nFields\n\nmetric::V: a static matrix that defines the Euclidean metric\n\nAvailable constructors\n\nMetricEuclid(m::AbstractMatrix{D, D, T})\nMetricEuclid(d::Integer, ::Type{T})\nMetricEuclid(d::Integer)\nMetricEuclid()\n\n\n\n\n\n","category":"type"},{"location":"api/#PhysicalVectors.MetricMinkowski","page":"API","title":"PhysicalVectors.MetricMinkowski","text":"MetricMinkowski\n\nA structure representing the Minkowski metric in an N-dimensional space. This metric is parameterised by:\n\nD: the dimensionality of the space \nT: the numeric type of the elements (e.g., Float64, Int64)\n\nThis type is a subtype of AbstractMetric{D, T} and is used to represent and work with Euclidean metrics in a statically-typed manner. The last element of the metric is the time-dependent one.\n\nFields\n\nmetric::V: a static matrix that defines the Minkowski metric\n\nAvailable constructors\n\nMetricMinkowski(d::Integer, ::Type{T}, ::Type{S})\nMetricMinkowski(d::Integer, ::Type{S}, ::Type{T})\nMetricMinkowski(d::Integer, ::Type{T})\nMetricMinkowski(d::Integer, ::Type{S})\nMetricMinkowski(d::Integer)\nMetricMinkowski() (1-dimensional default)\n\n\n\n\n\n","category":"type"},{"location":"api/#PhysicalVectors.MetricSignatureLorentzian","page":"API","title":"PhysicalVectors.MetricSignatureLorentzian","text":"MetricSignatureLorentzian{S} <: AbstractMetricSignature\n\nA struct representing a Lorentzian metric signature, where one dimension is treated differently (typically time) compared to the others (typically space).\n\n\n\n\n\n","category":"type"},{"location":"api/#PhysicalVectors.MetricSignatureRiemannian","page":"API","title":"PhysicalVectors.MetricSignatureRiemannian","text":"MetricSignatureRiemannian <: AbstractMetricSignature\n\nA struct representing a Riemannian metric signature, where all dimensions are treated equally and positively.\n\n\n\n\n\n","category":"type"},{"location":"api/#PhysicalVectors.MostlyMinus","page":"API","title":"PhysicalVectors.MostlyMinus","text":"MostlyMinus\n\nIn this case, the corresponding Minkowski-like metric has the signature (+, -, -, -). This is the convention used in high-energy physics, where the time component is positive and the spatial components are negative.\n\n\n\n\n\n","category":"type"},{"location":"api/#PhysicalVectors.MostlyPlus","page":"API","title":"PhysicalVectors.MostlyPlus","text":"MostlyPlus\n\nIn this case, the corresponding Minkowski-like metric has the signature (-, +, +, +). This is the convention used in general relativity, where the time component is negative and the spatial components are positive.\n\n\n\n\n\n","category":"type"},{"location":"api/#PhysicalVectors.VectorLorentz","page":"API","title":"PhysicalVectors.VectorLorentz","text":"VectorLorentz{D, T, V <: StaticVector{D, T}}\n\nA structure representing a Lorentzian vector in a physical vector space.\\  It is parameterised by:\n- D: dimensionality of the vector \n- T: element type of the vector \n- V: sub-type of StaticVector{D, T} representing the underlying static vector \n\n\nFields\n\nvector::V: the underlying static vector storing the data\n\nAvailable constructors\n\nVectorLorentz(v::StaticVector{D, T})\nVectorLorentz(v::AbstractVector{T})\nVectorLorentz(vs::Vararg{<: Number})\n\n\n\n\n\n","category":"type"},{"location":"api/#PhysicalVectors.VectorSpatial","page":"API","title":"PhysicalVectors.VectorSpatial","text":"VectorSpatial{D, T, V <: StaticVector{D, T}}\n\nA structure representing a spatial vector in a physical vector space.\\  It is parameterised by:\n- D: dimensionality of the vector \n- T: element type of the vector \n- V: sub-type of StaticVector{D, T} representing the underlying static vector \n\n\nFields\n\nvector::V: the underlying static vector storing the data.\n\nAvailable constructors\n\nVectorSpatial(v::StaticVector{D, T})\nVectorSpatial(v::AbstractVector{T})\nVectorSpatial(vs::Vararg{<: Number})\n\n\n\n\n\n","category":"type"},{"location":"api/#LinearAlgebra.cross","page":"API","title":"LinearAlgebra.cross","text":"cross\n\nDefines the cross function commonly used for vector products.  This is a placeholder definition and should be extended with specific methods for the desired types.\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.cross-Tuple{VectorSpatial, VectorSpatial}","page":"API","title":"LinearAlgebra.cross","text":"cross(v1::VectorSpatial, v2::VectorSpatial) -> VectorSpatial\n\nCompute the cross product of two 3D spatial vectors v1 and v2.\nThis function is only defined for 3-dimensional vectors.\nIt throw a DimensionMismatch error if the vectors are not 3D.\n\n\nInput\n\nv1::VectorSpatial:  first 3D spatial vector\nv2::VectorSpatial:  second 3D spatial vector\n\nOutput\n\nA new VectorSpatial object representing the cross product of v1 and v2.\n\nNotes\n\nThe cross product is only defined for 3-dimensional vectors. Ensure that both input vectors have a length of 3 before calling this function.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.dot","page":"API","title":"LinearAlgebra.dot","text":"dot\n\nDefines the dot function, which is typically used to compute the dot product of two vectors.  This is a placeholder definition and should be extended with specific methods for the desired types.\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.dot-Tuple{VectorSpatial, VectorSpatial}","page":"API","title":"LinearAlgebra.dot","text":"dot(v1::VectorSpatial{D, T1}, v2::VectorSpatial{D, T2}) -> Number\ndot(v1::VectorSpatial{D, T1}, v2::VectorSpatial{D, T2}, m::AbstractMetric) -> Number\n\nComputes the dot product of two spatial vectors v1 and v2 using their internal vector representations, for a given metric m. \nThe metric here makes no difference whatsoever, as the dot product is invariant under any metric, by construction.\nThe method involving the metric is included for consistency with the Lorentzian case.\n\n\nInput\n\nv1::VectorLorentz: first Lorentz vector\nv2::VectorLorentz: second Lorentz vector\n\n. (optional) m::AbstractMetric: an AbstractMetric-type object; defaults to Minkowski\n\nOutput\n\nNumber: the dot product of the two Lorentz vectors\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.dot-Union{Tuple{U}, Tuple{D}, Tuple{VectorLorentz, VectorLorentz, MetricMinkowski{D, U, MostlyMinus}}} where {D, U}","page":"API","title":"LinearAlgebra.dot","text":"dot(v1::VectorLorentz, v2::VectorLorentz, m::AbstractMetric) -> Number\ndot(v1::VectorLorentz{D, T1, V}, v2::VectorLorentz{D, T2, V}, ::MetricEuclid{D, U}) -> T\ndot(v1::VectorLorentz{D, T1, V}, v2::VectorLorentz{D, T2, V}, ::MetricMinkowski{D, U, S}) -> T\n\nComputes the dot product of two Lorentz vectors v1 and v2 using their internal vector representations, for a given metric m. \n\n\nInput\n\nv1::VectorLorentz: first Lorentz vector\nv2::VectorLorentz: second Lorentz vector\n\nOutput\n\n\"- Number: the dot product of the two Lorentz vectors.\"\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.norm-Tuple{PhysicalVectors.AbstractPhysicalVector}","page":"API","title":"LinearAlgebra.norm","text":"norm(v::AbstractPhysicalVector{D, T}) -> T\nnorm(v::AbstractPhysicalVector{D, T}, m::AbstractMetric{D, U, S}) -> T\n\nCompute the norm of a Lorentz vector v using the default metric.  The norm is defined as the square root of the dot product of the vector with itself.\n\nInput\n\nv::VectorLorentz: the Lorentz vector whose norm is to be computed.\n\nOutput\n\nT: The computed norm of the Lorentz vector\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalVectors.getChargeDensity-Union{Tuple{FourCurrentDensity{D, T, V}}, Tuple{V}, Tuple{T}, Tuple{D}} where {D, T<:Real, V}","page":"API","title":"PhysicalVectors.getChargeDensity","text":"getChargeDensity(v::FourCurrentDensity) -> AbstractFloat\n\nComputes the charge density of a FourCurrentDensity object v. The charge density is calculated as the temporal part of the four-current divided by the speed of light c.\n\nInput\n\nv::FourCurrentDensity: four-current object for which the charge density is to be computed \n\nOutput\n\nAbstractFloat: the charge density corresponding to the given four-current in units of C/m³\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalVectors.getCurrentDensity-Tuple{FourCurrentDensity}","page":"API","title":"PhysicalVectors.getCurrentDensity","text":"getCurrent(v::FourCurrentDensity) -> VectorSpatial\n\nExtracts the spatial part of a FourCurrentDensity object.\n\nInput\n\nv::FourCurrentDensity: the four-current object from which the spatial part (current) is to be extracted\n\nOutput\n\nThe VectorSpatial representing the spatial current component of the input FourCurrentDensity\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalVectors.getEnergy-Union{Tuple{FourMomentum{D, T, V}}, Tuple{V}, Tuple{T}, Tuple{D}} where {D, T<:Real, V}","page":"API","title":"PhysicalVectors.getEnergy","text":"getEnergy(v::FourMomentum) -> AbstractFloat\n\nCompute the energy of a FourMomentum object v.  The energy is calculated as the temporal part of the four-momentum multiplied by the speed of light c.\n\nInput\n\nv::FourMomentum: four-momentum object for which the energy is to be computed\n\nOutput\n\nAbstractFloat: the energy corresponding to the given four-momentum in units of Joules\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalVectors.getLorentzianSignatureConvention-Union{Tuple{Type{MetricSignatureLorentzian{S}}}, Tuple{S}} where S","page":"API","title":"PhysicalVectors.getLorentzianSignatureConvention","text":"getLorentzianSignatureConvention(::Type{MetricSignatureLorentzian{S}}) where {S <: LorentzianMetricSignatureConvention} -> S\n\nRetrieve the signature convention type from a MetricSignatureLorentzian type.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalVectors.getMetricSignatureSign-Union{Tuple{Type{PhysicalVectors.AbstractMetric{D, T, MetricSignatureRiemannian}}}, Tuple{T}, Tuple{D}} where {D, T}","page":"API","title":"PhysicalVectors.getMetricSignatureSign","text":"getMetricSignatureSign(::AbstractMetric)\ngetMetricSignatureSign(::Type{AbstractMetric})\n\nRetrieves the signature sign of the metric.\n\nOutput\n\n+1 for \"mostly plus\" convention\n-1 for \"mostly minus\" convention\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalVectors.getMetricTensor-Union{Tuple{PhysicalVectors.AbstractMetric{D, T, S}}, Tuple{S}, Tuple{T}, Tuple{D}} where {D, T, S}","page":"API","title":"PhysicalVectors.getMetricTensor","text":"getMetric(m::AbstractMetric{D, T, S}) -> T\n\nRetrieve the metric tensor from an AbstractMetric object.\n\nInput\n\nm::AbstractMetric{D, T, S}: an instance of a subtype of AbstractMetric, where D is the dimensionality, T is the type of the metric tensor, and S is the metric signature convention.\n\nOutput\n\nT: the metric tensor associated with the given AbstractMetric object.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalVectors.getMomentum-Tuple{FourMomentum}","page":"API","title":"PhysicalVectors.getMomentum","text":"getMomentum(v::FourMomentum) -> VectorSpatial\n\nExtracts the spatial part of a FourMomentum object.\n\nInput\n\nv::FourMomentum: the four-momentum object from which the spatial part (momentum) is to be extracted\n\nOutput\n\nThe VectorSpatial representing the spatial momentum component of the input FourMomentum\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalVectors.getPosition-Tuple{FourPosition}","page":"API","title":"PhysicalVectors.getPosition","text":"getPosition(p::FourPosition) -> VectorSpatial\n\nRetrieve the spatial part of a FourPosition object.\n\nInput\n\nv::FourPosition: four-position object from which the time component is extracted\n\nOutput\n\nVectorSpatial: the spatial part of the four-position\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalVectors.getSpatialPart-Tuple{VectorLorentz}","page":"API","title":"PhysicalVectors.getSpatialPart","text":"getSpatialPart(v::VectorLorentz) -> VectorSpatial\n\nExtracts the spatial part of a VectorLorentz object. \nThe spatial part is obtained by taking all elements of the internal vector except the last one. \n\n\nInput\n\nv::VectorLorentz: a Lorentz vector from which the spatial part is to be extracted. \nm::AbstractMetric: an AbstractMetric-type object; defaults to Minkowski\n\nOutput\n\nVectorSpatial: an Euclidean vector containing the spatial components of the input Lorentz vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalVectors.getTemporalPart-Tuple{VectorLorentz}","page":"API","title":"PhysicalVectors.getTemporalPart","text":"getTemporalPart(v::VectorLorentz) -> Vector{T}\n\nExtracts the temporal part of a VectorLorentz object. \nThe temporal part is assumed to be the last element of the vector representation.\n\nInput\n\nv::VectorLorentz: Lorentz vector from which the temporal part is to be extracted\n\nOutput\n\nA one-element vector containing the temporal part of the input VectorLorentz\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalVectors.getTime-Union{Tuple{FourPosition{D, T, V}}, Tuple{V}, Tuple{T}, Tuple{D}} where {D, T<:Real, V}","page":"API","title":"PhysicalVectors.getTime","text":"getTime(p::FourPosition) -> AbstractFloat\n\nComputes the time component of a FourPosition object by dividing its temporal part by the speed of light c.\n\nInput\n\nv::FourPosition: four-position object from which the time component is extracted\n\nOutput\n\nAbstractFloat: the time component of the four-position\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalVectors.isMetricLorentzian-Union{Tuple{PhysicalVectors.AbstractMetric{D, T, MetricSignatureRiemannian}}, Tuple{T}, Tuple{D}} where {D, T}","page":"API","title":"PhysicalVectors.isMetricLorentzian","text":"isMetricRiemannian(m::AbstractMetric{D, T, S}) -> Bool\nisMetricLorentzian(m::AbstractMetric{D, T, S}) -> Bool\n\nDetermines whether the given metric is Riemannian or Lorentzian based on its signature.\n\nInput\n\nm::AbstractMetric{D, T, S}: an instance of a subtype of AbstractMetric, where D is the dimensionality, T is the type of the metric tensor, and S is the metric signature convention.\n\nOutput\n\ntrue if the metric is Lorentzian\nfalse if the metric is Riemannian\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalVectors.isMetricRiemannian-Union{Tuple{PhysicalVectors.AbstractMetric{D, T, MetricSignatureRiemannian}}, Tuple{T}, Tuple{D}} where {D, T}","page":"API","title":"PhysicalVectors.isMetricRiemannian","text":"isMetricRiemannian(m::AbstractMetric{D, T, S}) -> Bool\nisMetricLorentzian(m::AbstractMetric{D, T, S}) -> Bool\n\nDetermines whether the given metric is Riemannian or Lorentzian based on its signature.\n\nInput\n\nm::AbstractMetric{D, T, S}: an instance of a subtype of AbstractMetric, where D is the dimensionality, T is the type of the metric tensor, and S is the metric signature convention.\n\nOutput\n\ntrue if the metric is Riemannian\nfalse if the metric is Lorentzian\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalVectors.isMostlyPlus-Union{Tuple{PhysicalVectors.AbstractMetric{D, T, MetricSignatureRiemannian}}, Tuple{T}, Tuple{D}} where {D, T}","page":"API","title":"PhysicalVectors.isMostlyPlus","text":"isMostlyPlus(m::MetricMinkowski) -> Bool\nisMostlyMinus(m::MetricMinkowski) -> Bool\n\nDetermines the signature convention of the Minkowski metric. \n\nInput\n\nm::MetricMinkowski{D, T, MostlyPlus}:  Minkowski metric object with \"mostly plus\" convention\nm::MetricMinkowski{D, T, MostlyMinus}:  Minkowski metric object with \"mostly minus\" convention\n\nOutput\n\ntrue if the metric is \"mostly plus\"\nfalse if the metric is \"mostly minus\"\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalVectors.norm2-Tuple{PhysicalVectors.AbstractPhysicalVector}","page":"API","title":"PhysicalVectors.norm2","text":"norm2(v::AbstractPhysicalVector{D, T}) -> T\nnorm2(v::AbstractPhysicalVector{D, T}, m::AbstractMetric{D, U, S}) -> T\nnorm²(args...) -> T\n\nCompute the squared norm of a Lorentz vector v using the default metric.  The norm is defined as the square root of the dot product of the vector with itself.\n\nInput\n\nv::AbstractPhysicalVector: the vector\nm::AbstractMetric: the metric used to compute the dot product (optional)\n\nOutput\n\nT: The computed norm2 of the Lorentz vector\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalVectors.numberOfDimensions","page":"API","title":"PhysicalVectors.numberOfDimensions","text":"numberOfDimensions(metric::AbstractMetric{D, T}) -> D\nnumberOfDimensions(vector::AbstractPhysicalVector{D, T}) -> D\n\nRetrieve the number of dimensions of an object. This function is not exported, as it is intended for internal use within packages.\n\n\n\n\n\n","category":"function"},{"location":"api/#PhysicalVectors.numberOfDimensions-Union{Tuple{PhysicalVectors.AbstractPhysicalVector{D, T}}, Tuple{T}, Tuple{D}} where {D, T}","page":"API","title":"PhysicalVectors.numberOfDimensions","text":"numberOfDimensions(v::AbstractPhysicalVector{D, T}) -> D\n\nReturns the number of dimensions of a given physical vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalVectors.@generateFourVector-Tuple{Any}","page":"API","title":"PhysicalVectors.@generateFourVector","text":"@generateFourVector(quantity)\n\nMacro to generate a FourQuantity type and its associated methods.\n\nThis macro defines a new struct type for a four-dimensional physical quantity,  along with constructors and utility methods for operations such as dot products  and accessing temporal and spatial parts.\n\nInput\n\nquantity: name of the four-dimensional quantity to be generated\n\nGenerated Code\n\nA struct definition for the quantity type, which is a subtype of AbstractPhysicalVector\nConstructors for the quantity type:\n\n-- from a `VectorLorentz` object\n-- from an `AbstractVector`\n-- from a variable number of scalar arguments\n\nOverloaded Base.getproperty to delegate property access to the underlying VectorLorentz\nUtility functions:\n\n-- `getTemporalPart`: the temporal part of the vector\n-- `getSpatialPart`:retrieves the spatial part of the vector\n-- `dot`: computes the dot product of two `quantity` objects, optionally using a metric\n\n\n\n\n\n","category":"macro"},{"location":"api/#PhysicalVectors.@physicalVectorConstructors-Tuple{Any}","page":"API","title":"PhysicalVectors.@physicalVectorConstructors","text":"@physicalVectorConstructors(vector)\n\nA macro that generates constructor methods for a custom VectorXXX sub-typing from AbstractPhysicalVector.\nThis macro is not exported and is intended for internal use within the package. \nThe generated constructors allow for the creation of VectorXXX instances from different input types, including: \n1. Static Vectors (SVector):\n. Accepts an SVector{D, T} where D is the dimension and T is a subtype of Number. \n. Returns an instance of vector parameterised by D, T, and the type of the input vector. \n2. Abstract Vectors: \n. Accepts an AbstractVector{T} where T is a subtype of Number. \n. Converts the input vector to a mutable MVector and returns an instance of vector parameterised by the length of the input vector, T, and the type of the converted vector. \n3. Varargs: \n. Accepts a variable number of arguments of type T (where T is a subtype of Number). \n. Constructs an MVector from the arguments and returns an instance of vector. \nThis macro simplifies the creation of constructors for custom vector types, ensuring compatibility with various input formats.\n\n\n\n\n\n","category":"macro"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"Vectors can be defined in any dimension desired.\n\nx = VectorSpatial(1., 0.) ## 2D vector\n\nIn the case of \"four\" vectors (which can be in any dimension), the last entry correspond to the temporal part. It has to be defined in a consistent way with respect to the spatial part, with the cs.\n\nX = FourPosition(1e10, 0, 0, c)\nx = getSpatialPart(X)\nct = getTemporalPart(X)\n\nNote that c is explicitly defined as a constant, referring to the speed of light in S.I. units.\n\nA few operations based on four-vectors and the metric are implemented by default, including inner product.\n\nV = VectorLorentz(3., 0., 0., 1.)\ng = MetricMinkowski(4)\nv = dot(V, v, g)\n\nAll vectors accept basic arithmetic operations.\n\nx1 = VectorSpatial(1., 2., 0.)\nx2 = VectorSpatial(0., 0., 1.)\nx = x1 + x2 # VectorSpatial(1., 2., 1.)\ny = 2. * x1 # VectorSpatial(2., 4., 0.)\n\nAlthough this has not yet been explicitly tested, Unitful quantities should also be accepted as input, although there are currently no checks preventing inconsistencies such as:\n\nX = FourPosition(u\"kg\", 0, 0, c)","category":"section"},{"location":"#PhysicalVectors.jl","page":"Home","title":"PhysicalVectors.jl","text":"PhysicalVectors.jl is a Julia package for representing and manipulating physical vectors in various geometric spaces, such as Euclidean and Lorentzian spaces.  It provides a flexible and efficient framework for working with vectors that have physical or geometric interpretations.\n\nThe vectors can be implemented in any dimension.  For instance, a VectorLorentz can be implemented in 1+1D, which enables a wide range of analyses.\n\nThis package is closely related to PhysicalVectors, which is currently under development (private). Functionalities such as Lorentz boosts, for example, are being implemented directly in this other package.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Support for Euclidean and Lorentzian vector spaces.\nAbstract and concrete vector types (VectorEuclid, VectorLorentz, etc.).\nIntegration with StaticArrays.jl for efficient static vector operations.\nSupport for custom metrics and dot products.\nExtensible framework for defining new vector types.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"To install the package, use the Julia package manager:\n\nusing Pkg\nPkg.add(\"https://github.com/rafaelab/PhysicalVectors.jl\")\n\nThis package is not in Julia's registry yet, until it is fully debugged.","category":"section"},{"location":"#Development-notes","page":"Home","title":"Development notes","text":"I was tempted to implement specific physical quantities such as PositionVector, VelocityVector, etc. While this would be great for dispatching, it also creates some complications that would require loads of lines of code to fix, as well as some advanced macros. Therefore, the basic types are really VectorSpatial (for ND vectors), and VectorLorentz (for (N + 1)D vectors, where N is the number of spatial dimensions). Nevertheless, convenient types that I use a lot such as FourMomentum, FourPosition, FourVelocity, and FourCurrentDensity are provided.","category":"section"},{"location":"#To-do-list","page":"Home","title":"To-do list","text":"Implement coordinate systems (spherical, cylindrical, etc).\nCompute some useful quantities such as rapidity, from the four-vectors. ","category":"section"}]
}
